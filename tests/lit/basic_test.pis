# CHECK: def foo ():
def foo():
    # CHECK-NEXT: var a0 :Int = 0
    var a0: Int = 0
    var a1 = 0
    var a2

# CHECK: def basic-types ():
# CHECK-NEXT: var a :[Int]
# CHECK-NEXT: var b :{Int}
# CHECK-NEXT: var c :{Str:Int}
def basic-types():
    var a: [Int] # list
    var b: {Int} # set
    var c: {Str : Int} # dict

# CHECK: def basic-control-flow (a :Int, b :Int) -> Int:
def basic-control-flow(a:Int, b:Int) -> Int:
    # CHECK-NEXT: return a if a > b else b
    return a if a > b else b

# CHECK: def basic-emacs-call (name :Str, age :Int) -> nil:
def basic-emacs-call(name:Str, age:Int) -> nil:
    # CHECK-NEXT: %message(%format-string("name: %s, age: %s", name, age))
    %message(%format-string("name: %s, age: %s", name, age))

# CHECK: def basic-if-else (v :Int):
def basic-if-else(v: Int):
    if v < 0:
        %message("v < 0")
    # CHECK: elif v < 10:
    elif v < 10:
        %message("0 < v < 10")
    # CHECK: else:
    else:
        # CHECK-NEXT: %message("v >= 10")
        %message("v >= 10")

# CHECK: class Fruit:
class Fruit:
    var -shape: [Int]
    var -size: Int
    var -weight: Int
    var -name: Str

    # CHECK: def __init__ (self, name :Str, size :Str):
    def __init__(self, name:Str, size:Str):
        # CHECK-NEXT: self.-name = name
        self.-name = name
        # CHECK-NEXT: self.-size = size
        self.-size = size

    @property
    def name(self) -> Str:
        return self.-name

    @property
    def size(self) -> Int:
        return self.-size

# CHECK: let apple = Fruit("Apple", 12)
let apple = Fruit("Apple", 12)

@pub
def pub-foo():
    return

# CHECK: @pub(tolisp = "basic-module-foo")
@pub(tolisp = "basic-module-foo")
# CHECK-NEXT: def pub-foo-renamed ():
def pub-foo-renamed():
    return

@pub
let pub-var = 0

# public variable could be export to lisp with specific name
# CHECK: @pub(tolisp = "basic-module-pub-var")
# CHECK-NEXT: let pub-var-1 = 0
@pub(tolisp = "basic-module-pub-var")
let pub-var-1 = 0

# CHECK: @template[T0, T1]
# CHECK-NEXT: def ty_foo (a :T0, b :T1) -> T0:
@template[T0, T1]
def ty_foo(a: T0, b: T1) -> T0:
    return

# CHECK: let v-of-foo = ty_foo[Int, Float]()
let v-of-foo = ty_foo[Int, Float]()

# CHECK: @template[T]
@template[T]
# CHECK-NEXT: def ty_foo1 () -> T:
def ty_foo1() -> T:
    return
